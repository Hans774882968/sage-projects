

# This file was *autogenerated* from the file 2-point-distance/point_dist_2d_add_eq.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0)
_sage_const_1 = Integer(1)
_sage_const_2 = Integer(2)
_sage_const_3 = Integer(3)
_sage_const_4 = Integer(4)


def get_grobner_basis(n):
    # 创建变量
    R_vars_str = []
    for i in range(n):
        R_vars_str.append(f'x{i}')
    for i in range(n):
        R_vars_str.append(f'y{i}')
    for i in range(n):
        R_vars_str.append(f'λ{i}')  # 每个点一个拉格朗日乘子

    # 只有定义λ字典序最大才能得到一元多项式
    R = PolynomialRing(QQ, R_vars_str, order='lex')
    vars_dict = {name: R(name) for name in R_vars_str}

    x = [vars_dict[f'x{i}'] for i in range(n)]
    y = [vars_dict[f'y{i}'] for i in range(n)]
    lam = [vars_dict[f'λ{i}'] for i in range(n)]
    R_vars = [vars_dict[v] for v in R_vars_str]

    # 目标函数：S = sum_{i<j} [(xi - xj)^2 + (yi - yj)^2]
    S = _sage_const_0
    for i in range(n):
        for j in range(i + _sage_const_1, n):
            S += (x[i] - x[j]) ** _sage_const_2 + (y[i] - y[j]) ** _sage_const_2

    # 拉格朗日函数 L = S - sum λ_i (x_i^2 + y_i^2 - 1)
    L = S
    for i in range(n):
        L -= lam[i] * (x[i] ** _sage_const_2 + y[i] ** _sage_const_2 - _sage_const_1)

    # 构造偏导方程组
    eqs = []
    for i in range(n):
        eqs.append(diff(L, x[i]))
        eqs.append(diff(L, y[i]))
    for i in range(n):
        eqs.append(x[i] ** _sage_const_2 + y[i] ** _sage_const_2 - _sage_const_1)  # 约束
    '''
    这样写并不能让 n = 4 的情况直接出答案
    if n == 4:
        eqs.append(2 * x[0] ^ 2 - 1)
        eqs.append(2 * y[0] ^ 2 - 1)
        eqs.append(x[0] - y[0])
    else:
        eqs.append(x[0] - 1)
        eqs.append(y[0])
    '''
    # 额外添加约束：让一点为定点
    eqs.append(x[_sage_const_0] - _sage_const_1)
    eqs.append(y[_sage_const_0])

    I = ideal(eqs)
    G = I.groebner_basis()

    return G, x, y, lam, R_vars


def get_grobner_lambda_fixed(n, sol_dict, lam):
    lambda_sol_list = [sol_dict[lam[i]] for i in range(n)]
    R_vars_str = []
    for i in range(n):
        R_vars_str.append(f'x{i}')
    for i in range(n):
        R_vars_str.append(f'y{i}')
    R = PolynomialRing(QQ, R_vars_str, order='lex')
    vars_dict = {name: R(name) for name in R_vars_str}

    x = [vars_dict[f'x{i}'] for i in range(n)]
    y = [vars_dict[f'y{i}'] for i in range(n)]
    S = _sage_const_0
    for i in range(n):
        for j in range(i + _sage_const_1, n):
            S += (x[i] - x[j]) ** _sage_const_2 + (y[i] - y[j]) ** _sage_const_2

    L = S
    for i in range(n):
        L -= lambda_sol_list[i] * (x[i] ** _sage_const_2 + y[i] ** _sage_const_2 - _sage_const_1)

    eqs = []
    for i in range(n):
        eqs.append(diff(L, x[i]))
        eqs.append(diff(L, y[i]))
    for i in range(n):
        eqs.append(x[i] ** _sage_const_2 + y[i] ** _sage_const_2 - _sage_const_1)
    '''
    这样写并不能让 n = 4 的情况直接出答案
    if n == 4:
        eqs.append(2 * x[0] ^ 2 - 1)
        eqs.append(2 * y[0] ^ 2 - 1)
        eqs.append(x[0] - y[0])
    else:
        eqs.append(x[0] - 1)
        eqs.append(y[0])
    '''
    # 额外添加约束：让一点为定点
    eqs.append(x[_sage_const_0] - _sage_const_1)
    eqs.append(y[_sage_const_0])

    I = ideal(eqs)
    G = I.groebner_basis()
    return G


def max_sum_of_squared_distances(n):
    if n < _sage_const_2:
        return _sage_const_0

    G, _, _, lam, R_vars = get_grobner_basis(n)
    '''
    n = 3 ：
    λ2^4 - 9*λ2^3 + 26*λ2^2 - 24*λ2 即 t(t-2)(t-3)(t-4)
    n = 4 ：
    λ3^5 - 16*λ3^4 + 92*λ3^3 - 224*λ3^2 + 192*λ3 即 t(t-2)(t-4)^2(t-6)
    '''
    for g in G:
        print(g)

    all_solutions = []
    # 1. 解出 λ_{n-1}
    last_poly = G[-_sage_const_1]
    vars_in_last = last_poly.variables()
    if len(vars_in_last) == _sage_const_1 and vars_in_last[_sage_const_0] == lam[n - _sage_const_1]:
        lam_n_1 = vars_in_last[_sage_const_0]
        poly_SR = SR(last_poly)
        lam_n_1_sols = solve(poly_SR == _sage_const_0, SR(lam_n_1))
        lam_n_1_sols = [sol.rhs() for sol in lam_n_1_sols if sol.rhs().is_real()]

        # 2. 逐层回代
        for val in lam_n_1_sols:
            current_sol = {lam_n_1: QQbar(val) if val in QQ else val}
            solved_vars = {lam_n_1}

            # 从倒数第二项开始向前代入
            for i in range(len(G) - _sage_const_2, -_sage_const_1, -_sage_const_1):
                g = G[i]
                '''
                将已知变量代入
                LLM 的代码在这里报错 TypeError: keys do not match self's parent
                问 LLM ，它胡说八道。但我自己 debug 发现，只需要这么写：
                new_var = next((item for item in R_vars if item == rv), None)
                就能让变量的类型正确，这代码也就能跑通了
                '''
                g_sub = g.subs(current_sol)
                if not g_sub:
                    continue
                remaining_vars = [v for v in g_sub.variables() if v not in solved_vars]

                if len(remaining_vars) == _sage_const_1:
                    rv = remaining_vars[_sage_const_0]
                    # 转为符号表达式求解
                    g_SR = SR(g_sub)
                    try:
                        sols_v = solve(g_SR == _sage_const_0, SR(rv))
                        if sols_v:
                            sol_val = sols_v[_sage_const_0].rhs()
                            new_var = next((item for item in R_vars if item == rv), None)
                            current_sol[new_var] = QQbar(sol_val) if sol_val in QQ else sol_val
                            solved_vars.add(new_var)
                        else:
                            break  # 无解
                    except Exception as e:
                        print('解方程遇到报错', e)
                        break  # 求解失败
                elif len(remaining_vars) == _sage_const_0:
                    # 已满足，跳过
                    continue
                else:
                    # 多变量，暂时跳过（实际中 Gröbner 基应为三角形）
                    continue

            all_solutions.append(current_sol.copy())

    print(f"\nn = {n} 时，找到 {len(all_solutions)} 组 λ 解：")
    for idx, sol in enumerate(all_solutions):
        print(f"解 {idx + _sage_const_1}:")
        for i in range(n):
            print(f"  λ{i} = {sol.get(lam[i], '未求出')}")

    for sol_dict in all_solutions:
        G2 = get_grobner_lambda_fixed(n, sol_dict, lam)
        print(sol_dict, '对应', G2)
        '''
        n = 3 时：
        {λ2: 4, λ1: 2, λ0: 2, y2: 0, y1: 0, y0: 0, x2: -1, x1: 1, x0: 1} 对应 [x0 - 1, x1 - 1, x2 + 1, y0, y1, y2]
        {λ2: 2, λ1: 4, λ0: 2, y2: 0, y1: 0, y0: 0, x2: 1, x1: -1, x0: 1} 对应 [x0 - 1, x1 + 1, x2 - 1, y0, y1, y2]
        {λ2: 3, λ1: 3, λ0: 3, y2: -1/2*sqrt(3), y1: 1/2*sqrt(3), y0: 0, x2: -1/2, x1: -1/2, x0: 1} 对应 [y2^2 - 3/4, x0 - 1, x1 + 1/2, x2 + 1/2, y0, y1 + y2]
        {λ2: 0, λ1: 0, λ0: 0, y2: 0, y1: 0, y0: 0, x2: 1, x1: 1, x0: 1} 对应 [x0 - 1, x1 - 1, x2 - 1, y0, y1, y2]
        n = 4 时：
        {λ3: 6, λ2: 2, λ1: 2, λ0: 2, y3: 0, y2: 0, y1: 0, y0: 0, x3: -1, x2: 1, x1: 1, x0: 1} 对应 [x0 - 1, x1 - 1, x2 - 1, x3 + 1, y0, y1, y2, y3]
        {λ3: 2, λ2: 6, λ1: 2, λ0: 2, y3: 0, y2: 0, y1: 0, y0: 0, x3: 1, x2: -1, x1: 1, x0: 1} 对应 [x0 - 1, x1 - 1, x2 + 1, x3 - 1, y0, y1, y2, y3]
        {λ3: 4, λ2: 4, λ1: 4, λ0: 4, y0: 0, x0: 1} 对应 [x3*y2^2 + x2*y3^2 + y2^2 + 2*y2*y3 + y3^2, x2*y2*y3 + x2*y3^2 + y2*y3 + y3^2, x3*y2*y3 - x2*y3^2 - y2*y3 - y3^2, y2^2*y3 + y2*y3^2, x2^2 + y2^2 - 1, x2*x3 + y2*y3 + x2 + x3 + 1, x3^2 + y3^2 - 1, x0 - 1, x1 + x2 + x3 + 1, y0, y1 + y2 + y3]
        {λ3: 0, λ2: 0, λ1: 0, λ0: 0, y3: 0, y2: 0, y1: 0, y0: 0, x3: 1, x2: 1, x1: 1, x0: 1} 对应 [x0 - 1, x1 - 1, x2 - 1, x3 - 1, y0, y1, y2, y3]
        第三个对应最大值16
        '''


max_sum_of_squared_distances(_sage_const_3)
max_sum_of_squared_distances(_sage_const_4)
